GAMEABOUTSQUARES.Conf

GAMEABOUTSQUARES.State
 load/save/change level

GAMEABOUTSQUARES.Interface
 misc high level interface manipulation

GAMEABOUTSQUARES.Model
 addheart, addsquare ?
 checkwincondition
 playermove
 resetlvl

GAMEABOUTSQUARES.Hooks

GAMEABOUTSQUARES.Engine


x = $('.square')[0].gameObject



architecture
 eventpage (compute in separate thread?) + contentscript


AI
iterative deepening
no backtracking
using the language stack

initial state
goal test
 forall teams: position of square = position of heart
expand
 pick a team (cycle depending on level?) number of teams modulo level. fancy for 
 new state with that team moved, recurse
 if backtracked pick next team
 detect when to stop

representation:

fixed:
heart (circle)
arrow

changing:
square
 position + direction


{
 //fixed part of the problem
 problem = 
 {
 [][]pos; nothing or arrow or team number(=circle)
 }

 min/max indices to know when to prune (if square outside = prune) -> could be better but who care

 //moving parts of the problem
 state = 
 {
 squares = [{team, pos, dir}, ...];
 or squares[team]={pos, dir} ?
 or pos[][] = {team, dir}
 }
}


$('.game-object').map(function(){var go = this.gameObject; var ret = {posX: go.posX, posY: go.posY};
    if(go.constructor == GAMEABOUTSQUARES.Engine.Square) ret.gameObject = {team: go.team, direction: go.action.name};
    else if(go.core.constructor == GAMEABOUTSQUARES.Engine.Heart) ret.gameObject = go.team;
    else if(go.constructor == GAMEABOUTSQUARES.Engine.Tile && go.core.constructor == GAMEABOUTSQUARES.Engine.Action) ret.gameObject = go.core.name;
    return ret; 
})


window.postMessage(x.get(), '*')
